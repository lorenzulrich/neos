<?php
namespace TYPO3\Neos\TypoScript;

use TYPO3\Eel\FlowQuery\FlowQuery;
use TYPO3\Flow\Annotations as Flow;
use TYPO3\Neos\Domain\Service\ConfigurationContentDimensionPresetSource;
use TYPO3\TYPO3CR\Domain\Model\NodeInterface;
use TYPO3\TYPO3CR\Domain\Service\ContentDimensionCombinator;
use TYPO3\TypoScript\Exception as TypoScriptException;

/**
 * TypoScript implementation for a variant menu.
 *
 * The items generated by this menu will be all possible variants (according to the configured dimensions
 * and presets) of the given node (including the given node).
 *
 * If a 'dimension' is configured via TypoScript, only the possible variants for that dimension will
 * be included in the menu, any other dimensions will be kept from the current context.
 *
 * Main Options:
 * - dimension (optional, string): name of the dimension which this menu should be limited to. Example: "language".
 */
class VariantMenuImplementation extends AbstractMenuImplementation
{
    /**
     * @Flow\Inject
     * @var ContentDimensionCombinator
     */
    protected $contentDimensionCombinator;

    /**
     * @return string
     */
    public function getDimension()
    {
        return $this->tsValue('dimension');
    }

    /**
     * Builds the array of Menu items for this variant menu
     */
    protected function buildItems()
    {
        $menuItems = [];
        $targetDimensionsToMatch = [];

        if ($this->getDimension() !== null) {
            $targetDimensionsToMatch = $this->currentNode->getContext()->getTargetDimensions();
            unset($targetDimensionsToMatch[$this->getDimension()]);
        }

        foreach ($this->contentDimensionCombinator->getAllAllowedCombinations() as $allowedCombination) {
            $targetDimensions = $this->calculateTargetDimensionsForCombination($allowedCombination);

            // skip variants not matching the current target dimensions (except the dimension this menu covers)
            if ($targetDimensionsToMatch !== []) {
                foreach ($targetDimensionsToMatch as $dimensionName => $dimensionValue) {
                    if ($targetDimensions[$dimensionName] !== $dimensionValue) {
                        continue 2;
                    }
                }
            }

            $nodeInDimensions = $this->getNodeInDimensions($allowedCombination, $targetDimensions);
            if ($nodeInDimensions !== null && $this->isNodeHidden($nodeInDimensions)) {
                $nodeInDimensions = null;
            }

            $menuItems[] = [
                'node' => $nodeInDimensions,
                'state' => $this->calculateItemState($nodeInDimensions),
                'label' => $nodeInDimensions === null ? '' : $nodeInDimensions->getLabel(),
                'dimensions' => $allowedCombination,
                'targetDimensions' => $targetDimensions
            ];
        }

        return $menuItems;
    }

    /**
     * Get the current node in the given dimensions.
     * If it doesn't exist the method returns null.
     *
     * @param array $dimensions
     * @param array $targetDimensions
     * @return NodeInterface|null
     */
    protected function getNodeInDimensions(array $dimensions, array $targetDimensions)
    {
        $q = new FlowQuery([$this->currentNode]);

        return $q->context(
            [
                'dimensions' => $dimensions,
                'targetDimensions' => $targetDimensions
            ]
        )->get(0);
    }

    /**
     * Calculates the target dimensions for a given dimension combination.
     *
     * @param array $dimensionCombination
     * @return array
     */
    protected function calculateTargetDimensionsForCombination(array $dimensionCombination)
    {
        $targetDimensions = [];
        foreach ($dimensionCombination as $dimensionName => $dimensionValues) {
            $targetDimensions[$dimensionName] = reset($dimensionValues);
        }

        return $targetDimensions;
    }
}
