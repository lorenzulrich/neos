<?php
namespace TYPO3\Neos\TypoScript;

use TYPO3\Eel\FlowQuery\FlowQuery;
use TYPO3\Eel\Utility;
use TYPO3\Flow\Annotations as Flow;
use TYPO3\Neos\Domain\Service\ConfigurationContentDimensionPresetSource;
use TYPO3\TYPO3CR\Domain\Model\NodeInterface;
use TYPO3\TYPO3CR\Domain\Service\ContentDimensionCombinator;
use TYPO3\TypoScript\Exception as TypoScriptException;

/**
 * TypoScript implementation for a dimensions menu.
 *
 * The items generated by this menu will be all possible variants (according to the configured dimensions
 * and presets) of the given node (including the given node).
 *
 * If a 'dimension' is configured via TypoScript, only the possible variants for that dimension will
 * be included in the menu, any other dimensions will be kept from the current context.
 *
 * Main Options:
 * - dimension (optional, string): name of the dimension which this menu should be limited to. Example: "language".
 * - labelExpression (string): Expression to use for label generation if "dimension" is not set.
 */
class DimensionsMenuImplementation extends AbstractMenuImplementation
{

    /**
     * @Flow\Inject
     * @var ConfigurationContentDimensionPresetSource
     */
    protected $configurationContentDimensionPresetSource;

    /**
     * @Flow\Inject
     * @var ContentDimensionCombinator
     */
    protected $contentDimensionCombinator;

    /**
     * @Flow\Inject(lazy=false)
     * @var \TYPO3\Eel\EelEvaluatorInterface
     */
    protected $eelEvaluator;

    /**
     * @Flow\InjectConfiguration(package="TYPO3.TYPO3CR", path="labelGenerator.eel.defaultContext")
     * @var array
     */
    protected $defaultContextConfiguration;

    /**
     * @return string
     */
    public function getDimension()
    {
        return $this->tsValue('dimension');
    }

    /**
     * @return string
     */
    public function getLabelExpression()
    {
        return $this->tsValue('labelExpression');
    }

    /**
     * Builds the array of Menu items for this variant menu
     */
    protected function buildItems()
    {
        $menuItems = [];
        $targetDimensionsToMatch = [];
        $allDimensionPresets = $this->configurationContentDimensionPresetSource->getAllPresets();

        $pinnedDimensionName = $this->getDimension();
        if ($pinnedDimensionName !== null) {
            $targetDimensionsToMatch = $this->currentNode->getContext()->getTargetDimensions();
            unset($targetDimensionsToMatch[$pinnedDimensionName]);
        }

        foreach ($this->contentDimensionCombinator->getAllAllowedCombinations() as $allowedCombination) {
            $targetDimensions = $this->calculateTargetDimensionsForCombination($allowedCombination);

            // skip variants not matching the current target dimensions (except the dimension this menu covers)
            if ($targetDimensionsToMatch !== []) {
                foreach ($targetDimensionsToMatch as $dimensionName => $dimensionValue) {
                    if ($targetDimensions[$dimensionName] !== $dimensionValue) {
                        continue 2;
                    }
                }
            }

            $nodeInDimensions = $this->getNodeInDimensions($allowedCombination, $targetDimensions);
            if ($nodeInDimensions !== null && $this->isNodeHidden($nodeInDimensions)) {
                $nodeInDimensions = null;
            }

            // determine metadata for target dimensions of node
            array_walk($targetDimensions, function (&$dimensionValue, $dimensionName, $allDimensionPresets) use ($pinnedDimensionName) {
                $dimensionValue = [
                    'value' => $dimensionValue,
                    'label' => $allDimensionPresets[$dimensionName]['presets'][$dimensionValue]['label'],
                    'isPinnedDimension' => ($pinnedDimensionName === null || $dimensionName == $pinnedDimensionName) ? true : false
                ];
            }, $allDimensionPresets);

            if ($pinnedDimensionName === null) {
                $itemLabel = Utility::evaluateEelExpression($this->getLabelExpression(), $this->eelEvaluator, array('node' => $nodeInDimensions), $this->defaultContextConfiguration);
            } else {
                $itemLabel = $targetDimensions[$pinnedDimensionName]['label'];
            }

            $menuItems[] = [
                'node' => $nodeInDimensions,
                'state' => $this->calculateItemState($nodeInDimensions),
                'label' => $itemLabel,
                'dimensions' => $allowedCombination,
                'targetDimensions' => $targetDimensions,
                'pinnedDimensionName' => $pinnedDimensionName
            ];
        }

        return $menuItems;
    }

    /**
     * Get the current node in the given dimensions.
     * If it doesn't exist the method returns null.
     *
     * @param array $dimensions
     * @param array $targetDimensions
     * @return NodeInterface|null
     */
    protected function getNodeInDimensions(array $dimensions, array $targetDimensions)
    {
        $q = new FlowQuery([$this->currentNode]);

        return $q->context(
            [
                'dimensions' => $dimensions,
                'targetDimensions' => $targetDimensions
            ]
        )->get(0);
    }

    /**
     * Calculates the target dimensions for a given dimension combination.
     *
     * @param array $dimensionCombination
     * @return array
     */
    protected function calculateTargetDimensionsForCombination(array $dimensionCombination)
    {
        $targetDimensions = [];
        foreach ($dimensionCombination as $dimensionName => $dimensionValues) {
            $targetDimensions[$dimensionName] = reset($dimensionValues);
        }

        return $targetDimensions;
    }
}
